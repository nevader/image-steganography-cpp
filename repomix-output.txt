This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-06-03T10:36:09.638Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
CMakeLists.txt
Controller/ArgumentController.cpp
Controller/ArgumentController.h
Controller/BaseController.cpp
Controller/BaseController.h
Controller/FlagController.cpp
Controller/FlagController.h
Enums/Error.h
Enums/Extension.h
Enums/Flag.h
main.cpp
Model/Bmp.cpp
Model/Bmp.h
Model/BmpHeader.h
Model/Image.cpp
Model/Image.h
Model/Message.cpp
Model/Message.h
Model/Pixels.cpp
Model/Pixels.h
Model/Ppm.cpp
Model/Ppm.h
View/CommandLineInterface.cpp
View/CommandLineInterface.h

================================================================
Repository Files
================================================================

================
File: CMakeLists.txt
================
cmake_minimum_required(VERSION 3.23)
project(steganography)

set(CMAKE_CXX_STANDARD 14)

add_executable(steganography main.cpp Model/Bmp.cpp Model/Bmp.h Model/Ppm.cpp Model/Ppm.h Model/Pixels.cpp Model/Pixels.h Model/Message.cpp Model/Message.h Controller/FlagController.cpp Controller/FlagController.h Model/Image.cpp Model/Image.h Controller/ArgumentController.cpp Controller/ArgumentController.h View/CommandLineInterface.cpp View/CommandLineInterface.h Enums/Flag.h Enums/Error.h Controller/BaseController.cpp Controller/BaseController.h)

================
File: Controller/ArgumentController.cpp
================
//
// Created by Nevader on 25.12.2022.
//


#include "ArgumentController.h"

void ArgumentController::help(const string &fileName) {
    ui.printHelp(fileName);
}

void ArgumentController::encrypt(char *filePath, char *messageToEncrypt) {

    Extension extension = fileCheck(filePath);

    switch (extension) {

        case PPM:
            ppm.loadImage(filePath);
            if (message.canWriteMessage(messageToEncrypt, ppm)) {
                message.writeMessage(messageToEncrypt, ppm);
                ppm.writeImage(filePath);
                ui.printEncrypt();
            } else {
                ui.printArgumentError(filePath, MESSAGE_TO_LONG, "");
            }
            break;

        case BMP:
            if (bmp.loadImage(filePath)) {
            if (message.canWriteMessage(messageToEncrypt, bmp)) {
                message.writeMessage(messageToEncrypt, bmp);
                bmp.writeImage(filePath);
                ui.printEncrypt();
            } else {
                ui.printArgumentError(filePath, MESSAGE_TO_LONG, "");
            }
            } else {
                ui.printArgumentError(filePath, FILE_FORMAT, to_string(bmp.getBitsPerPixel()));
            }
            break;

        case NOT_SUPPORTED:
            ui.printArgumentError(filePath, FILE_EXTENSION, getFileExtensionToString(filePath));
            break;
    }
}

void ArgumentController::decrypt(char *filePath) {

    Extension extension = fileCheck(filePath);

    switch (extension) {

        case PPM:
            ppm.loadImage(filePath);
            if (message.getFlag(ppm) == -1) {
                ui.printArgumentError(filePath, NO_ENCODED_MESSAGE, "");
                break;
            } else {
                ui.printDecrypt(message.readMessage(ppm));
                break;
            }

        case BMP:
            bmp.loadImage(filePath);
            if (message.getFlag(bmp) == -1) {
                ui.printArgumentError(filePath, NO_ENCODED_MESSAGE, "");
                break;
            } else {
                ui.printDecrypt(message.readMessage(bmp));
                break;
            }

        case NOT_SUPPORTED:
            ui.printArgumentError(filePath, FILE_EXTENSION, getFileExtensionToString(filePath));
            break;
    }

}

void ArgumentController::info(char *filePath) {

    if (!isFileExisting(filePath)) {
        ui.printArgumentError(filePath, FILE_PATH, "");
        return;
    }

    Extension extension = fileCheck(filePath);


    struct stat file_stats{};

    switch (extension) {

        case PPM:
            if (ppm.loadImage(filePath)) {

                stat(filePath, &file_stats);
                ui.printInfo(ppm.getWidth(), ppm.getHeight(),
                             file_stats.st_mtime, file_stats.st_size, filePath, PPM);
            } else {
                stat(filePath, &file_stats);
                ui.printInfo(ppm.getWidth(), ppm.getHeight(),
                             file_stats.st_mtime, file_stats.st_size, filePath, NOT_SUPPORTED);
            }
            break;

        case BMP:
            if (bmp.loadImage(filePath)) {

                stat(filePath, &file_stats);
                ui.printInfo(bmp.getWidth(), bmp.getHeight(),
                             file_stats.st_mtime, file_stats.st_size, filePath, BMP);
            } else {
                stat(filePath, &file_stats);
                ui.printInfo(bmp.getWidth(), bmp.getHeight(),
                             file_stats.st_mtime, file_stats.st_size, filePath, NOT_SUPPORTED);
            }

            break;

        case NOT_SUPPORTED:
            ui.printArgumentError(filePath, FILE_EXTENSION, getFileExtensionToString(filePath));
            break;

    }
}

void ArgumentController::check(char *filePath, const char *messageToEncrypt) {

    if (!isFileExisting(filePath)) {
        ui.printArgumentError(filePath, FILE_PATH, "");
        return;
    }

    Extension extension = fileCheck(filePath);
    BYTE_4 maxBits;
    BYTE_4 messageBits;
    string messageToString = messageToEncrypt;
    BYTE_4 messageToEncryptLength = messageToString.size();

    switch (extension) {

        case PPM:

            ppm.loadImage(filePath);
            messageBits = message.getFlag(ppm);
            maxBits = message.getMaxLength(ppm);

            ui.printCheck(messageBits, maxBits, messageToEncryptLength);
            break;

        case BMP:

            bmp.loadImage(filePath);
            messageBits = message.getFlag(bmp);
            maxBits = message.getMaxLength(bmp);

            ui.printCheck(messageBits, maxBits, messageToEncryptLength);
            break;

        case NOT_SUPPORTED:
            break;

    }
}

bool compare_ignore_case(char a, char b) {
    return tolower(a) == tolower(b);
}


Extension ArgumentController::fileCheck(char *filePath) {
    string ppmex = ".ppm";
    string bmpex = ".bmp";
    string extension = getFileExtensionToString(filePath);

    if (equal(extension.begin(), extension.end(), ppmex.begin(), compare_ignore_case)) {
        return PPM;
    } else if (equal(extension.begin(), extension.end(), bmpex.begin(), compare_ignore_case)) {
        return BMP;
    } else {
        return NOT_SUPPORTED;
    }
}


ArgumentController::ArgumentController(CommandLineInterface &ui) : ui(ui) {

}


string ArgumentController::getFileExtensionToString(const char *filePath) {
    string path = filePath;
    size_t pos = path.find_last_of('.');
    return path.substr(pos);
}

bool ArgumentController::isFileExisting(char *filePath) {

    ifstream file(filePath);
    return file.good();

}

================
File: Controller/ArgumentController.h
================
//
// Created by Nevader on 25.12.2022.
//

#ifndef STEGANOGRAPHY_ARGUMENTCONTROLLER_H
#define STEGANOGRAPHY_ARGUMENTCONTROLLER_H

#include <cstring>
#include <iostream>
#include "../model/Ppm.h"
#include "../model/Message.h"
#include "../model/Bmp.h"
#include "../View/CommandLineInterface.h"
#include "../Enums/Extension.h"
#include <sys/stat.h>
#include <ctime>

using namespace std;


class ArgumentController {

private:
    CommandLineInterface ui;
    Ppm ppm;
    Bmp bmp;
    Message message;

public:

    explicit ArgumentController(CommandLineInterface &ui);

    void help(const string &fileName);

    void info(char *filePath);

    void encrypt(char *filePath, char *messageToEncrypt);

    void decrypt(char *filePath);

    void check(char *filePath, const char *messageToEncrypt);

    /**
* @brief Extracts the file extension from a file path.
* @param filePath The file path from which the extension should be extracted.
* @return The file extension as a string.
*/
    string getFileExtensionToString(const char *filePath);

    bool isFileExisting(char *filePath);

/**
@brief Check the file extension of the given file path
@param filePath The file path of the image to check
@return Extension The file extension as enumeration (PPM, BMP, NOT_SUPPORTED)
*/
    Extension fileCheck(char *filePath);

};


#endif //STEGANOGRAPHY_ARGUMENTCONTROLLER_H

================
File: Controller/BaseController.cpp
================
//
// Created by Nevader on 26.12.2022.
//

#include "BaseController.h"

BaseController::BaseController(int argc, char *argv[], FlagController &flags, ArgumentController &arguments)
        : flags(flags), arguments(arguments) {
    argumentCount = argc;
    argumentArray = argv;

    string exePath = argv[0];
    size_t pos = exePath.find_last_of('\\');
    string exeName = exePath.substr(pos + 1);

    fileName = exeName;
}

void BaseController::run() {

    if (!flags.isThereFlagError()) {

        for (int i = 1; i < argumentCount; ++i) {

            switch (flags.stringToFlag(argumentArray[i])) {

                case HELP:
                    arguments.help(fileName);
                    break;

                case INFO:
                    arguments.info(argumentArray[i + 1]);
                    i += 1;
                    break;

                case ENCRYPT:
                    arguments.encrypt(argumentArray[i + 1], argumentArray[i + 2]);
                    i += 2;
                    break;

                case DECRYPT:
                    arguments.decrypt(argumentArray[i + 1]);
                    i++;
                    break;

                case CHECK:
                    arguments.check(argumentArray[i + 1], argumentArray[i + 2]);
                    i += 2;
                    break;

                case UNKNOWN:
                    break;
            }
        }
    }
}

================
File: Controller/BaseController.h
================
//
// Created by Nevader on 26.12.2022.
//

#ifndef STEGANOGRAPHY_BASECONTROLLER_H
#define STEGANOGRAPHY_BASECONTROLLER_H


#include "ArgumentController.h"
#include "FlagController.h"
#include "../View/CommandLineInterface.h"

class BaseController {

private:
    int argumentCount;
    char **argumentArray;
    string fileName;

    ArgumentController arguments;
    FlagController flags;

public:
    BaseController(int argc, char *argv[], FlagController &flags, ArgumentController &arguments);
/**
@brief Runs the program based on passed command line arguments.
This method checks for any flag errors using the isThereFlagError method of the FlagController class.
If there are no errors, it iterates through the command line arguments and calls the appropriate method in
the ArgumentController class based on the flag.
*/
    void run();
};


#endif //STEGANOGRAPHY_BASECONTROLLER_H

================
File: Controller/FlagController.cpp
================
#include "FlagController.h"


Flag FlagController::stringToFlag(const string &str) {

    if (str == "-h" || str == "--help") {
        return HELP;

    } else if (str == "-i" || str == "--info") {
        return INFO;

    } else if (str == "-e" || str == "--encrypt") {
        return ENCRYPT;

    } else if (str == "-d" || str == "--decrypt") {
        return DECRYPT;

    } else if (str == "-c" || str == "--check") {
        return CHECK;

    } else {
        return UNKNOWN;
    }
}

bool FlagController::isThereFlagError() {

    int argsCount;

    if (argumentCount == 1) {
        string exePath = argumentArray[0];
        size_t pos = exePath.find_last_of('\\');
        string exeName = exePath.substr(pos + 1);
        ui.printHelp(exeName);
        return true;
    }

    for (int i = 1; i < argumentCount; i++) {

        string currentFlag = argumentArray[i];

        if (currentFlag.front() == '-' || (i == 1 && currentFlag.front() != '-')) {

            argsCount = argumentCounter(i);

            switch (stringToFlag(currentFlag)) {
                case HELP:
                    if (argsCount != 0) {
                        ui.printFlagError(TOO_MANY_ARGUMENTS, HELP, argumentArray[i + argsCount]);
                        return true;
                    }
                    break;

                case INFO:
                    if (argsCount > 1) {
                        ui.printFlagError(TOO_MANY_ARGUMENTS, INFO, argumentArray[i + argsCount]);
                        return true;

                    } else if (argsCount < 1) {
                        ui.printFlagError(TOO_FEW_ARGUMENTS, INFO, argumentArray[i]);
                        return true;
                    }
                    break;

                case ENCRYPT:
                    if (argsCount > 2) {
                        ui.printFlagError(TOO_MANY_ARGUMENTS, ENCRYPT, argumentArray[i + argsCount]);
                        return true;

                    } else if (argsCount < 2) {
                        ui.printFlagError(TOO_FEW_ARGUMENTS, ENCRYPT, "");
                        return true;
                    }
                    break;

                case DECRYPT:
                    if (argsCount > 1) {
                        ui.printFlagError(TOO_MANY_ARGUMENTS, DECRYPT, argumentArray[i + argsCount]);
                        return true;

                    } else if (argsCount < 1) {
                        ui.printFlagError(TOO_FEW_ARGUMENTS, DECRYPT, argumentArray[i]);
                        return true;
                    }
                    break;

                case CHECK:
                    if (argsCount > 2) {
                        ui.printFlagError(TOO_MANY_ARGUMENTS, CHECK, argumentArray[i + argsCount]);
                        return true;

                    } else if (argsCount < 2) {
                        ui.printFlagError(TOO_FEW_ARGUMENTS, CHECK, "");
                        return true;
                    }
                    break;

                case UNKNOWN:
                    ui.printFlagError(INVALID_FLAG, UNKNOWN, currentFlag);
                    return true;
            }
        }
    }

    return false;
}

int FlagController::argumentCounter(int currIndex) {

    bool nextFlag = false;
    int counter = 0;
    while (!nextFlag && currIndex < argumentCount - 1) {
        string next = argumentArray[currIndex + 1];
        if (next.front() != '-') {
            counter++;
            currIndex++;
        } else {
            nextFlag = true;
        }
    }

    return counter;
}

FlagController::FlagController(CommandLineInterface &ui, int &argc, char **argv)
        : ui(ui), argumentCount(argc) {
    this->argumentArray = argv;

}

================
File: Controller/FlagController.h
================
//
// Created by Nevader on 18.12.2022.
//

#ifndef STEGANOGRAPHY_FLAGCONTROLLER_H
#define STEGANOGRAPHY_FLAGCONTROLLER_H

#include <iostream>
#include "ArgumentController.h"
#include "../ENUMS/Flag.h"
#include "../Enums/Error.h"
#include "../View/CommandLineInterface.h"
#include <map>

using namespace std;


class FlagController {

private:
    const CommandLineInterface ui;
    const int argumentCount;
    char **argumentArray;

public:
    FlagController(CommandLineInterface &ui, int &argumentCount, char **argumentArray);

    Flag stringToFlag(const string &str);

/**
@brief Check for flag errors in the command line arguments.
This function iterates through all of the command line arguments, starting at index 1. It checks
for the presence of flags, and whether they have the correct number of arguments. If any errors
are found, it will print an error message and return true. Otherwise, it will return false.

@return True if flag errors were found, false otherwise.
*/
    bool isThereFlagError();

/**

@brief Counts the number of arguments following a flag.

@param currIndex The index of the current flag in the command line arguments.

@return The number of arguments following the current flag.
*/
    int argumentCounter(int currIndex);

};


#endif //STEGANOGRAPHY_FLAGCONTROLLER_H

================
File: Enums/Error.h
================
//
// Created by Nevader on 26.12.2022.
//

#ifndef STEGANOGRAPHY_ERROR_H
#define STEGANOGRAPHY_ERROR_H

enum Error {
    FILE_PATH,
    FILE_EXTENSION,
    INVALID_FLAG,
    TOO_MANY_ARGUMENTS,
    TOO_FEW_ARGUMENTS,
    MESSAGE_TO_LONG,
    NO_ENCODED_MESSAGE,
    FILE_FORMAT
};

#endif //STEGANOGRAPHY_ERROR_H

================
File: Enums/Extension.h
================
//
// Created by Krzysiek on 27.12.2022.
//

#ifndef STEGANOGRAPHY_EXTENSION_H
#define STEGANOGRAPHY_EXTENSION_H

enum Extension {
    NOT_SUPPORTED,
    PPM,
    BMP,
};

#endif //STEGANOGRAPHY_EXTENSION_H

================
File: Enums/Flag.h
================
//
// Created by Nevader on 26.12.2022.
//

#ifndef STEGANOGRAPHY_FLAG_H
#define STEGANOGRAPHY_FLAG_H

enum Flag {
    HELP,
    INFO,
    ENCRYPT,
    DECRYPT,
    CHECK,
    UNKNOWN

};

#endif //STEGANOGRAPHY_FLAG_H

================
File: main.cpp
================
#include "controller/FlagController.h"
#include "Controller/BaseController.h"


int main(int argc, char *argv[]) {

    CommandLineInterface ui{};

    FlagController flags(ui, argc, argv);
    ArgumentController arguments(ui);

    BaseController baseController(argc, argv, flags, arguments);
    baseController.run();

    return 0;

}

================
File: Model/Bmp.cpp
================
//
// Created by Nevader on 04.12.2022.
//

#include "Bmp.h"
#include <iostream>
#include <fstream>
#include <unistd.h>
#include <bitset>


bool Bmp::loadImage(const char *filePath) {

    ifstream file;
    file.open(filePath, ios::in | ios::binary);

    file.read((char *) &fileHeader, sizeof(bmpFileHeader));
    file.read((char *) &infoHeader, sizeof(bmpInfoHeader));


    width = infoHeader.width;
    height = infoHeader.height;

    if (infoHeader.bitsPerPixel != 24) {
        bitsPerPixel = infoHeader.bitsPerPixel;
        return false;
    }

    pixels.setWidth(width);
    pixels.setPixelArraySize(width, height);

    const int padding_amount = ((4 - (width * 3) % 4) % 4);

    for (int y = 0; y < height; ++y) {
        for (int x = 0; x < width; ++x) {
            BYTE colors[3];
            file.read((reinterpret_cast<char *>(colors)), 3);
            pixels.setColor(RED, colors[2], x, y);
            pixels.setColor(BLUE, colors[1], x, y);
            pixels.setColor(GREEN, colors[0], x, y);
        }
        file.ignore(padding_amount);
    }
    file.close();
    return true;
}


void Bmp::writeImage(const char *filePath) {

    ofstream file;

    file.open(filePath, ios::out | ios::binary);

    BYTE padding_array[3] = {0, 0, 0};
    const int padding_amount = ((4 - (width * 3) % 4) % 4);

    BYTE fh[sizeof(bmpFileHeader)];
    memcpy(fh, &fileHeader, sizeof(bmpFileHeader));

    BYTE fi[sizeof(bmpInfoHeader)];
    memcpy(fi, &infoHeader, sizeof(bmpInfoHeader));

    file.write(reinterpret_cast<char *>(fh), sizeof(bmpFileHeader));
    file.write(reinterpret_cast<char *>(fi), sizeof(bmpInfoHeader));

    for (int y = 0; y < height; ++y) {
        for (int x = 0; x < width; ++x) {
            auto r = static_cast<unsigned char>(pixels.getColor(RED, x, y));
            auto b = static_cast<unsigned char>(pixels.getColor(BLUE, x, y));
            auto g = static_cast<unsigned char>(pixels.getColor(GREEN, x, y));

            unsigned char colors[] = {g, b, r};
            file.write(reinterpret_cast<char *>(colors), 3);
        }

        file.write(reinterpret_cast<char *>(padding_array), padding_amount);
    }
    file.close();
}

int Bmp::getBitsPerPixel() const {
    return bitsPerPixel;
}

================
File: Model/Bmp.h
================
//
// Created by Nevader on 04.12.2022.
//

#ifndef STEGANOGRAPHY_BMP_H
#define STEGANOGRAPHY_BMP_H

#include <vector>
#include "BmpHeader.h"
#include "Pixels.h"
#include "Image.h"

using namespace std;


class Bmp : public Image {
private:

    bmpFileHeader fileHeader{};
    bmpInfoHeader infoHeader{};
    int bitsPerPixel{};

public:

/**
 * @brief Loads an image from a BMP file and stores it in memory.
 *
 * @param filePath The path to the BMP file to be loaded.
 * @return True if the image was successfully loaded, false otherwise.
 */
    bool loadImage(const char *filePath) override;

 /**
 * @brief Writes the image stored in the Bmp object to a BMP file.
 *
 * @param filePath The name of the BMP file to write the image to.
 */
    void writeImage(const char *filePath) override;

    int getBitsPerPixel() const;

};


#endif //STEGANOGRAPHY_BMP_H

================
File: Model/BmpHeader.h
================
//
// Created by Krzysiek on 05.12.2022.
//

#ifndef STEGANOGRAPHY_BMPHEADER_H
#define STEGANOGRAPHY_BMPHEADER_H


typedef unsigned char BYTE;
typedef unsigned short BYTE_2;
typedef unsigned int BYTE_4;


#pragma pack(push, 1)
/**
 * @brief Represents the file header of a BMP file.
 *
 * The file header contains information about the size and layout of the BMP file.
 */
struct bmpFileHeader {

    BYTE_2 fileType;
    BYTE_4 fileSize;
    BYTE_2 reserved1;
    BYTE_2 reserved2;
    BYTE_4 pixelsOffset;

};
#pragma pack(pop)


#pragma pack(push, 1)
/**
 * @brief Represents the info header of a BMP file.
 *
 * The info header contains information about the dimensions and color depth of the image data in the BMP file.
 */
struct bmpInfoHeader {

    BYTE_4 headerSize;
    BYTE_4 width;
    BYTE_4 height;
    BYTE_2 planes;
    BYTE_2 bitsPerPixel;
    BYTE_4 compression;
    BYTE_4 imageSize;
    BYTE_4 xPixelsPerMeter;
    BYTE_4 yPixelsPerMeter;
    BYTE_4 colorsUsed;
    BYTE_4 colorsImportant;

};
#pragma pack(pop)

#endif //STEGANOGRAPHY_BMPHEADER_H

================
File: Model/Image.cpp
================
//
// Created by Krzysiek on 19.12.2022.
//

#include "Image.h"

int Image::getWidth() const {
    return width;
}

int Image::getHeight() const {
    return height;
}

Pixels &Image::getPixels() {
    return pixels;
}

================
File: Model/Image.h
================
//
// Created by Krzysiek on 19.12.2022.
//

#ifndef STEGANOGRAPHY_IMAGE_H
#define STEGANOGRAPHY_IMAGE_H


#include "Pixels.h"

class Image {
protected:

    int width{};
    int height{};
    Pixels pixels;

public:

    virtual bool loadImage(const char *filePath) = 0;

    virtual void writeImage(const char *filePath) = 0;

    int getWidth() const;

    int getHeight() const;

    Pixels &getPixels();
};


#endif //STEGANOGRAPHY_IMAGE_H

================
File: Model/Message.cpp
================
//
// Created by Nevader on 17.12.2022.
//

#include <cstring>
#include "Message.h"
#include "Image.h"
#include <bitset>
#include <iostream>

using namespace std;


void Message::writeMessage(const char *message, Image &image) {

    char flagString[] = {'s', 'i', 'z', 'e'};

    unsigned int messageLengthInBytes = strlen(message);
    unsigned int messageLengthInBits = (messageLengthInBytes * 8);

    bitset<sizeof(BYTE_4) * 8> messageLength{messageLengthInBits};

    messageLengthInBits += 64;

    bool messageToBitsArray[messageLengthInBits];

    int currentIndex = 0;


    for (int i = 0; i < 4; ++i) {
        for (int j = 7; j >= 0; --j) {
            messageToBitsArray[currentIndex] = getBit(flagString[i], j);
            currentIndex++;
        }
    }

    for (int i = 0; i < 32; ++i) {
        messageToBitsArray[currentIndex] = messageLength.test(32 - 1 - i);
        currentIndex++;
    }


    for (int i = 0; i < messageLengthInBytes; ++i) {
        for (int j = 7; j >= 0; --j) {
            messageToBitsArray[currentIndex] = getBit(message[i], j);
            currentIndex++;
        }
    }


    currentIndex = 0;

    for (int y = 0; y < image.getWidth() && currentIndex < messageLengthInBits; ++y) {
        for (int x = 0; x < image.getHeight() && currentIndex < messageLengthInBits; ++x) {

            RBG rbg = image.getPixels().getRbg(x, y);


            rbg.red = modifyBit(rbg.red, 1, messageToBitsArray[currentIndex]);
            currentIndex++;
            rbg.red = modifyBit(rbg.red, 0, messageToBitsArray[currentIndex]);
            currentIndex++;


            rbg.blue = modifyBit(rbg.blue, 1, messageToBitsArray[currentIndex]);
            currentIndex++;
            rbg.blue = modifyBit(rbg.blue, 0, messageToBitsArray[currentIndex]);
            currentIndex++;


            rbg.green = modifyBit(rbg.green, 1, messageToBitsArray[currentIndex]);
            currentIndex++;
            rbg.green = modifyBit(rbg.green, 0, messageToBitsArray[currentIndex]);
            currentIndex++;

            image.getPixels().setRbg(rbg, x, y);
        }
    }
}


string Message::readMessage(Image &image) {

    int bitOffset = 64;
    BYTE_4 getSize = getFlag(image) + bitOffset;
    bool size_text[getSize];

    int current_index = 0;

    for (int y = 0; y < image.getWidth() && current_index < getSize; ++y) {
        for (int x = 0; x < image.getHeight() && current_index < getSize; ++x) {

            RBG rbg = image.getPixels().getRbg(x, y);

            size_text[current_index] = getBit(rbg.red, 1);
            current_index++;
            size_text[current_index] = getBit(rbg.red, 0);
            current_index++;

            size_text[current_index] = getBit(rbg.blue, 1);
            current_index++;
            size_text[current_index] = getBit(rbg.blue, 0);
            current_index++;

            size_text[current_index] = getBit(rbg.green, 1);
            current_index++;
            size_text[current_index] = getBit(rbg.green, 0);
            current_index++;
        }
    }

    string text;
    string out;

    for (int i = 64; i < getSize; ++i) {
        text += to_string(size_text[i]);
    }

    do {
        string byte = text.substr(0, 8);  // Get eight "bits"

        out += (char) stoi(byte, nullptr, 2);  // Convert and output to file

        text = text.substr(8);  // The remaining bits
    } while (!text.empty());

    return out;


}

BYTE_4 Message::getFlag(Image &image) {

    bool size_text[64];
    int current_index = 0;

    for (int y = 0; y < image.getWidth() && current_index < 64; ++y) {
        for (int x = 0; x < image.getHeight() && current_index < 64; ++x) {

            RBG rbg = image.getPixels().getRbg(x, y);

            size_text[current_index] = getBit(rbg.red, 1);
            current_index++;
            size_text[current_index] = getBit(rbg.red, 0);
            current_index++;

            size_text[current_index] = getBit(rbg.blue, 1);
            current_index++;
            size_text[current_index] = getBit(rbg.blue, 0);
            current_index++;

            size_text[current_index] = getBit(rbg.green, 1);
            current_index++;
            size_text[current_index] = getBit(rbg.green, 0);
            current_index++;
        }
    }

    string text;
    string out;

    for (int i = 0; i < 32; ++i) {
        text += to_string(size_text[i]);
    }

    do {
        std::string byte = text.substr(0, 8);  // Get eight "bits"

        out += (char) stoi(byte, nullptr, 2);  // Convert and output to file

        text = text.substr(8);  // The remaining bits
    } while (!text.empty());

    if (out != "size") {
        return -1;
    }

    for (int i = 32; i < 64; ++i) {
        text += to_string(size_text[i]);
    }

    bitset<32> lol(text);

    return lol.to_ulong();
}

BYTE Message::modifyBit(int input, int position, bool newBit) {
    BYTE mask = 1 << position;
    return ((input & ~mask) | (newBit << position));
}

bool Message::getBit(unsigned char byte, int position) {
    return (byte >> position) & 1;
}

BYTE_4 Message::getMaxLength(Image &image) {
    return ((image.getWidth() * image.getHeight() * 3) - 64) / 8;
}

bool Message::canWriteMessage(const char *message, Image &image) {
    string mess = message;
    BYTE_4 messageLength = mess.length();

    return getMaxLength(image) >= messageLength;
}

================
File: Model/Message.h
================
//
// Created by Nevader on 17.12.2022.
//

#ifndef STEGANOGRAPHY_MESSAGE_H
#define STEGANOGRAPHY_MESSAGE_H


#include <string>
#include "BmpHeader.h"
#include "Image.h"

class Message {

public:

/**
 * @brief Encodes a message in an image by modifying two least significant bits of the pixel values.
 *
 * @param message The message to be encoded in the image.
 * @param image The image in which to encode the message.
 */
    void writeMessage(const char *message, Image &image);

/**
 * @brief Extracts a message from an image by reading two least significant bits of the pixel values.
 *
 * @param image The image from which to extract the message.
 *
 * @return The message embedded in the image, as a string.
 */
    string readMessage(Image &image);

    /**
 * @brief This function reads the first 64 bits from least significant bits of the red, blue,
 * and green channels of each pixel in the image. The first 32 bits are
 * reserved for the "size" flag, which indicates the presence of an encoded message in the image. If the flag is not
 * present, the function returns -1. Otherwise, it extracts the size of the message from the following 32 bits and
 * returns it as an unsigned long.
   *
 * @param image The image from which to extract the size of the message.
 *
 * @return The size of the message, in bits. If the "size" flag is not present, the function returns -1.
 */
    BYTE_4 getFlag(Image &image);

/**
 * @brief Calculates the maximum message length that can be stored in an image.
 *
 * @param image The image for which to calculate the maximum message length.
 *
 * @return The maximum message length, in bytes.
 */
    BYTE_4 getMaxLength(Image &image);

/**
 * @brief Determines whether a message can be stored in an image.
 *
 * @param message The message to store.
 * @param image The image in which to store the message.
 *
 * @return `true` if the message can be stored in the image, `false` otherwise.
 */
    bool canWriteMessage(const char *message, Image &image);

/**
 * @brief Extracts a single bit from a byte.
 *
 * @param byte The byte from which to extract the bit.
 * @param position The position of the bit to extract, where 0 is the least significant bit and 7 is the most significant
 * bit.
 *
 * @return The value of the extracted bit, as a boolean.
 */
    bool getBit(unsigned char byte, int position);

/**
 * @brief Modifies a single bit in a byte.
 *
 * @param input The input byte.
 * @param position The position of the bit to modify, where 0 is the least significant bit and 7 is the most significant
 * bit.
 * @param newBit The new value of the bit.
 *
 * @return The modified byte.
 */
    BYTE modifyBit(int input, int position, bool newBit);

};


#endif //STEGANOGRAPHY_MESSAGE_H

================
File: Model/Pixels.cpp
================
//
// Created by Nevader on 14.12.2022.
//

#include "Pixels.h"

RBG::RBG() {
    red = 0;
    green = 0;
    blue = 0;
}

RBG::RBG(BYTE r, BYTE g, BYTE b) {
    red = r;
    green = g;
    blue = b;
}

RBG Pixels::getRbg(int x, int y) {
    return pixelsVector[y * width + x];
}

void Pixels::setRbg(RBG &rbg, int x, int y) {
    pixelsVector[y * width + x].blue = rbg.blue;
    pixelsVector[y * width + x].green = rbg.green;
    pixelsVector[y * width + x].red = rbg.red;
}

BYTE Pixels::getColor(COLOR color, int x, int y) {

    switch (color) {
        case RED:
            return pixelsVector[y * width + x].red;
        case BLUE:
            return pixelsVector[y * width + x].blue;
        case GREEN:
            return pixelsVector[y * width + x].green;
    }
    return 0;
}

void Pixels::setColor(COLOR color, BYTE value, int x, int y) {

    switch (color) {
        case RED:
            pixelsVector[y * width + x].red = value;
            break;
        case BLUE:
            pixelsVector[y * width + x].blue = value;
            break;
        case GREEN:
            pixelsVector[y * width + x].green = value;
            break;
    }
}

void Pixels::setPixelArraySize(int width, int height) {
    pixelsVector.resize(width * height);
}

void Pixels::setWidth(int mWidth) {
    width = mWidth;
}

================
File: Model/Pixels.h
================
//
// Created by Nevader on 14.12.2022.
//

#ifndef STEGANOGRAPHY_PIXELS_H
#define STEGANOGRAPHY_PIXELS_H

#include "BmpHeader.h"
#include <vector>

using namespace std;

enum COLOR {
    RED = 1,
    BLUE = 2,
    GREEN = 3
};

struct RBG {
    BYTE red;
    BYTE green;
    BYTE blue;

    RBG();

    RBG(BYTE r, BYTE g, BYTE b);
};

class Pixels {

private:
    vector<RBG> pixelsVector;
    int width;

public:
    /**
 * @brief Returns the RGB pixel values at a given position.
 *
 * @param x The x-coordinate of the pixel.
 * @param y The y-coordinate of the pixel.
 *
 * @return The RGB pixel values at the specified position.
 */
    RBG getRbg(int x, int y);


/**
 * @brief Sets the RGB pixel values at a given position.
 *
 * @param rbg The new RGB pixel values, represented as an `RBG` struct.
 * @param x The x-coordinate of the pixel.
 * @param y The y-coordinate of the pixel.
 */
    void setRbg(RBG &rbg, int x, int y);

/**
 * @brief Returns the value of a given color channel for a pixel at a given position.
 *
 * @param color The color channel to retrieve. This can be one of the following values: <br>
 * - `RED`: the red channel <br>
 * - `BLUE`: the blue channel <br>
 * - `GREEN`: the green channel <br>
 * @param x The x-coordinate of the pixel.
 * @param y The y-coordinate of the pixel.
 *
 * @return The value of the specified color channel for the pixel at the given position, as a byte (8-bit integer).
 */
    BYTE getColor(COLOR color, int x, int y);

/**
 * @brief Sets the value of a given color channel for a pixel at a given position.
 *
 * @param color The color channel to set. This can be one of the following values: <br>
 * - `RED`: the red channel <br>
 * - `BLUE`: the blue channel <br>
 * - `GREEN`: the green channel
 * @param value The new value for the color channel (0-255).
 * @param x The x-coordinate of the pixel.
 * @param y The y-coordinate of the pixel.
 */
    void setColor(COLOR color, BYTE value, int x, int y);

/**
 * @brief Resizes the array of RGB pixel values to match a given image size.
 *
 * @param width The width of the image, in pixels.
 * @param height The height of the image, in pixels.
 */
    void setPixelArraySize(int width, int height);

    void setWidth(int width);
};


#endif //STEGANOGRAPHY_PIXELS_H

================
File: Model/Ppm.cpp
================
//
// Created by Nevader on 14.12.2022.
//

#include <algorithm>
#include "Ppm.h"
#include "Pixels.h"


void Ppm::writeImage(const char *fileName) {

    ofstream file;
    file.open(fileName, ios::out);

    file << magicNumber << "\n";
    file << width << " ";
    file << height << "\n";
    file << maxColor;

    for (int y = 0; y < height; ++y) {
        file << "\n";
        for (int x = 0; x < width; ++x) {
            file << (int) pixels.getColor(RED, x, y) << " ";
            file << (int) pixels.getColor(BLUE, x, y) << " ";
            file << (int) pixels.getColor(GREEN, x, y) << " ";
        }
    }
    file.close();
}

bool Ppm::loadImage(const char *fileName) {

    ifstream file(fileName);
    vector<string> words;
    string line;
    string word;

    while (words.size() < 4) {
        getline(file, line);
        istringstream iss(line);
        while (iss >> word && words.size() < 4) {
            if (!word.find('#')) {
                break;
            } else {
                words.push_back(word);
            }
        }
    }


    magicNumber = words[0];
    width = stoi(words[1]);
    height = stoi(words[2]);
    maxColor = stoi(words[3]);

    if (!isAsciiEncoded()) {
        return false;
    }

    pixels.setWidth(width);
    pixels.setPixelArraySize(width, height);

    for (int y = 0; y < height; ++y) {
        for (int x = 0; x < width; ++x) {

            BYTE colors[3];
            int counter = 0;
            string color;

            while (counter < 3) {
                file >> color;
                colors[counter] = stoi(color);
                counter++;
            }
            pixels.setColor(RED, colors[0], x, y);
            pixels.setColor(BLUE, colors[1], x, y);
            pixels.setColor(GREEN, colors[2], x, y);
        }
    }
    file.close();
    return true;
}

bool Ppm::isAsciiEncoded() {
    if (magicNumber == "P3" || magicNumber == "p3") {
        return true;
    } else {
        return false;
    }
}

================
File: Model/Ppm.h
================
#include <iostream>
#include <fstream>
#include <vector>
#include <sstream>
#include "Pixels.h"
#include "Image.h"

using namespace std;

#ifndef STEGANOGRAPHY_PPM_H
#define STEGANOGRAPHY_PPM_H

class Ppm : public Image {

private:

    string magicNumber;
    int maxColor;

public:

 /**
 * @brief Write image data to a PPM file.
 * This function writes the image data stored in the object to a PPM file with the given file name.
 * If the file already exists, it will be overwritten.
 *
 * @param fileName The name of the file to write to.
 */
    void writeImage(const char *fileName) override;

 /**
 * @brief Loads an image in PPM format from a file and reads the
 * magic number, width, height, and maximum color value from the
 * first few lines. It then checks if the image is encoded in ASCII format, and returns `false` if it is not.
 *
 * @param fileName The name of the file from which to load the image.
 *
 * @return `true` if the image was successfully loaded, `false` otherwise.
 */
    bool loadImage(const char *fileName) override;

 /**
 * @brief Returns whether the PPM file is stored in ASCII format.
 * PPM files can be stored in either ASCII or binary format.
 *
 * @return True if the PPM file is stored in ASCII format, false if it is
 * stored in binary format.
 */
    bool isAsciiEncoded();

};


#endif //STEGANOGRAPHY_PPM_H

================
File: View/CommandLineInterface.cpp
================
//
// Created by Nevader on 26.12.2022.
//

#include "CommandLineInterface.h"


void CommandLineInterface::generateAscii(Flag flag) const {
    switch (flag) {
        case ENCRYPT:
            cout << ".------..------..------..------..------..------..------.\n"
                    "|E.--. ||N.--. ||C.--. ||R.--. ||Y.--. ||P.--. ||T.--. |\n"
                    "| (\\/) || :(): || :/\\: || :(): || (\\/) || :/\\: || :/\\: |\n"
                    "| :\\/: || ()() || :\\/: || ()() || :\\/: || (__) || (__) |\n"
                    "| '--'E|| '--'N|| '--'C|| '--'R|| '--'Y|| '--'P|| '--'T|\n"
                    "`------'`------'`------'`------'`------'`------'`------'\n";
            break;

        case DECRYPT:
            cout << ".------..------..------..------..------..------..------.\n"
                    "|D.--. ||E.--. ||C.--. ||R.--. ||Y.--. ||P.--. ||T.--. |\n"
                    "| :/\\: || (\\/) || :/\\: || :(): || (\\/) || :/\\: || :/\\: |\n"
                    "| (__) || :\\/: || :\\/: || ()() || :\\/: || (__) || (__) |\n"
                    "| '--'D|| '--'E|| '--'C|| '--'R|| '--'Y|| '--'P|| '--'T|\n"
                    "`------'`------'`------'`------'`------'`------'`------'\n";
            break;

        case HELP:
            cout << ".------..------..------..------.\n"
                    "|H.--. ||E.--. ||L.--. ||P.--. |\n"
                    "| :/\\: || (\\/) || :/\\: || :/\\: |\n"
                    "| (__) || :\\/: || (__) || (__) |\n"
                    "| '--'H|| '--'E|| '--'L|| '--'P|\n"
                    "`------'`------'`------'`------'\n";
            break;

        case INFO:
            cout << ".------..------..------..------.\n"
                    "|I.--. ||N.--. ||F.--. ||O.--. |\n"
                    "| (\\/) || :(): || :(): || :/\\: |\n"
                    "| :\\/: || ()() || ()() || :\\/: |\n"
                    "| '--'I|| '--'N|| '--'F|| '--'O|\n"
                    "`------'`------'`------'`------'\n";
            break;

        case CHECK:
            cout << ".------..------..------..------..------.\n"
                    "|C.--. ||H.--. ||E.--. ||C.--. ||K.--. |\n"
                    "| :/\\: || :/\\: || (\\/) || :/\\: || :/\\: |\n"
                    "| :\\/: || (__) || :\\/: || :\\/: || :\\/: |\n"
                    "| '--'C|| '--'H|| '--'E|| '--'C|| '--'K|\n"
                    "`------'`------'`------'`------'`------'\n";
            break;

        case UNKNOWN:
            cout << ".------..------..------..------..------.\n"
                    "|E.--. ||R.--. ||R.--. ||O.--. ||R.--. |\n"
                    "| (\\/) || :(): || :(): || :/\\: || :(): |\n"
                    "| :\\/: || ()() || ()() || :\\/: || ()() |\n"
                    "| '--'E|| '--'R|| '--'R|| '--'O|| '--'R|\n"
                    "`------'`------'`------'`------'`------'\n";
            break;
    }
}

void CommandLineInterface::printFlagError(Error error, Flag flag, const string &reason) const {

    switch (flag) {
        case HELP:
            generateAscii(UNKNOWN);
            cout << "ERROR: " << errorEnumToString(error) << " Flag '-h' takes zero arguments.\n";
            cout << "Try using -h or --help for more information.\n";
            break;

        case INFO:
            generateAscii(UNKNOWN);
            cout << "ERROR: " << errorEnumToString(error) << " Flag '-i' takes one argument.\n";
            cout << "Try using -h or --help for more information.\n";
            break;

        case ENCRYPT:
            generateAscii(UNKNOWN);
            cout << "ERROR: " << errorEnumToString(error) << " Flag '-e' takes two arguments.\n";
            cout << "Try using -h or --help for more information.\n";
            break;

        case DECRYPT:
            generateAscii(UNKNOWN);
            cout << "ERROR: " << errorEnumToString(error) << " Flag '-d' takes one argument.\n";
            cout << "Try using -h or --help for more information.\n";
            break;

        case CHECK:
            generateAscii(UNKNOWN);
            cout << "ERROR: " << errorEnumToString(error) << " Flag '-c' takes two arguments.\n";
            cout << "Try using -h or --help for more information.\n";
            break;

        case UNKNOWN:
            generateAscii(UNKNOWN);
            cout << "ERROR: " << errorEnumToString(error) << " Cannot recognise " << reason << " flag.\n";
            cout << "Try using -h or --help for more information.\n";
            break;
    }
}

string CommandLineInterface::errorEnumToString(Error error) const {

    switch (error) {

        case INVALID_FLAG:
            return "Invalid flag.";

        case TOO_MANY_ARGUMENTS:
            return "Too many arguments.";

        case TOO_FEW_ARGUMENTS:
            return "Too few arguments.";
        case MESSAGE_TO_LONG:
            break;
    }

    return "";
}


void CommandLineInterface::printArgumentError(char *file_path, Error error, const string &reason) const {

    switch (error) {

        case FILE_PATH:
            generateAscii(UNKNOWN);
            cout << "ERROR: Cannot open file: " << file_path << "\n";
            cout << "Check if the provided file path is correct or use -h for more information.\n";
            break;
        case FILE_EXTENSION:
            generateAscii(UNKNOWN);
            cout << "ERROR: File format: " << reason << " is not supported!\n";
            cout << "* Use -h for more information.\n";
            break;

        case MESSAGE_TO_LONG:
            generateAscii(UNKNOWN);
            cout << "ERROR: The given message is too long to be encoded in: \n" << file_path << "\n\n";
            break;
        case NO_ENCODED_MESSAGE:
            generateAscii(UNKNOWN);
            cout << "ERROR: Where is no encoded message in: " << file_path << "\n";
            break;
        case FILE_FORMAT:
            generateAscii(UNKNOWN);
            cout << "ERROR: Wrong file format. " << reason;
    }
}


void CommandLineInterface::printHelp(const string &file_name) const {

    generateAscii(HELP);
    cout << "Usage:\n ";
    cout << " * " << file_name << " [options] <path-to-image-source>\n ";
    cout << " * " << file_name << " [options] <path-to-image-source> \"message-to-encrypt\"\n\n";

    cout << "Available file formats: " << endl;
    cout << " * 24bit per pixel bitmap with .bmp extension." << endl;
    cout << " * ASCII encoded Portable PixMap with .ppm extension." << endl << endl;

    cout << "Flag options:" << endl;
    cout << "(-i or --info) <path-to-image-source>" << endl;
    cout << " * Prints information about image. (timestamp, format, image size, last modified date)\n" << endl;
    cout << "(-c or --check) <path-to-image-source> \"message-to-encrypt\"" << endl;
    cout << " * Checks if message can be encrypted in the given image or if there is message to be decrypted.\n" << endl;
    cout << "(-e or --encrypt) <path-to-image-source> \"message-to-encrypt\"" << endl;
    cout << " * Encrypts given message to the image.\n" << endl;
    cout << "(-d or --decrypt) <path-to-image-source>" << endl;
    cout << " * Decrypts message from given image and prints it to the console.\n" << endl;
    cout << "(-h or --help)" << endl;
    cout << " * Prints information about this program.\n" << endl;

}

void CommandLineInterface::printEncrypt() const {
    generateAscii(ENCRYPT);
    cout << "* Successfully encrypted message in given file.\n" << endl;

}

void CommandLineInterface::printDecrypt(const string &message) const {
    generateAscii(DECRYPT);
    cout << "* Successfully decrypted message from given file." << endl;
    cout << "* Press ENTER to read message...";
    char temp = 'x';
    while (temp != '\n')
        cin.get(temp);
    cout << endl;
    cout << "* Encrypted message: \n";
    cout << message;
    cout << endl;
    cout << endl;
}


void CommandLineInterface::printInfo(int width, int height, time_t timeStamp, int size, char *file_path,
                                     Extension extension) const {
    generateAscii(INFO);
    cout << "File path: " << file_path << endl;
    switch (extension) {

        case NOT_SUPPORTED:
            cout << "File format: " << "Not supported!" << endl;
            break;
        case PPM:
            cout << "File format: " << ".ppm - ASCII encoded." << endl;
            break;
        case BMP:
            cout << "File format: " << ".bmp - 24 bit per pixel." << endl;
            break;
    }
    cout << "Image resolution: " << width << " x " << height << endl;
    cout << "Image size: " << size / 8 << " bytes" << endl;
    cout << "Last modification time: " << ctime(&timeStamp) << endl;
}

void CommandLineInterface::printCheck(BYTE_4 messageFlag, BYTE_4 maxMessageSize, BYTE_4 messageToEncryptLength) const {
    generateAscii(CHECK);
    if (messageFlag == -1) {
        cout << "* There is no hidden message to decrypt in the given file." << endl;
    } else {
        cout << "* The file at the given path contains a message that can be decrypted." << endl;
    }
    cout << "* The maximum number of characters that can be encoded: " << maxMessageSize << endl;
    cout << "* Number of characters in the given message: " << messageToEncryptLength << endl << endl;

}

================
File: View/CommandLineInterface.h
================
#ifndef STEGANOGRAPHY_COMMANDLINEINTERFACE_H
#define STEGANOGRAPHY_COMMANDLINEINTERFACE_H

#include <iostream>
#include "../ENUMS/Flag.h"
#include "../Enums/Error.h"
#include "../Enums/Extension.h"
#include "../Model/BmpHeader.h"
#include <ctime>

using namespace std;

class CommandLineInterface {

public:
    void generateAscii(Flag flag) const;

    void printFlagError(Error error, Flag flag, const string &reason) const;

    void printArgumentError(char *file_path, Error error, const string &reason) const;

    string errorEnumToString(Error error) const;

    void printHelp(const string &file_name) const;

    void printEncrypt() const;

    void printDecrypt(const string &message) const;

    void printInfo(int width, int height, time_t timeStamp, int size, char *file_path, Extension extension) const;

    void printCheck(BYTE_4 messageFlag, BYTE_4 maxMessageSize, BYTE_4 messageToEncryptLength) const;

};


#endif //STEGANOGRAPHY_COMMANDLINEINTERFACE_H
